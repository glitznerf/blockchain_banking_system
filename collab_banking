pragma solidity ^0.6.11;

contract Bank {
    uint private interestRate; //in %
    address private owner;
    uint private bankReserve;
    CentralBank cBank;

    constructor(CentralBank centralBank) public {
        owner = msg.sender;
        bankReserve = 1000;
        interestRate = 20;
        cBank = centralBank;
        centralBank.registerBank(msg.sender);
    }

    struct account_holders {
        uint accountBal;
        uint lendAmount;
        uint lastUpdateTime;
    }

    mapping(address => account_holders) customers;

    function withdraw(uint withdrawAmt) public payable {
        require(withdrawAmt <= customers[msg.sender].accountBal);
        if (withdrawAmt > bankReserve) {
            interBankTransfer(withdrawAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= withdrawAmt;
        }
        
        customers[msg.sender].accountBal -= withdrawAmt;
        customers[msg.sender].lastUpdateTime = now;
        msg.sender.transfer(withdrawAmt);
    }

    function deposit() external payable {
        uint amount = interestWithAmt(msg.value);
        customers[msg.sender].accountBal += amount;
        bankReserve += amount;
    }

    function lend(uint lendAmt) public payable {
       if (lendAmt > bankReserve) {
            interBankTransfer(lendAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= lendAmt;
        }
        
        uint amount = interestWithAmt(lendAmt);
        customers[msg.sender].lendAmount += amount;
        msg.sender.transfer(uint(lendAmt));
    }

    function repayLoan() external payable {
        uint amount = msg.value;
        customers[msg.sender].lendAmount += amount;
        customers[msg.sender].lastUpdateTime = now;
        bankReserve += amount;
    }

    function getInterestRate() public view returns(uint) {
        require(interestRate >= 0, "Improper interest rate is set");
        return interestRate;
    }

    function updateInterestRate(uint newInterestRate) public {
        require(msg.sender == owner, "You are not allowed to update the interest rate");
        interestRate = newInterestRate;
    }

    function internalTransfer(address destination, uint amount) external {
        require(amount <= customers[msg.sender].accountBal, "Balance is not sufficient");
        customers[msg.sender].accountBal = interestWithAmt(customers[msg.sender].accountBal) - amount;
        customers[destination].accountBal = interestWithAmt(customers[destination].accountBal) + amount;
    }
    
    function interestWithAmt(uint principle) private returns(uint) {
        uint months = uint(ufixed(now-customers[msg.sender].lastUpdateTime)/(3600*24*30));
        ufixed interest = ufixed(principle*interestRate)/1200;
        customers[msg.sender].lastUpdateTime = now;
        return principle + uint(interest);
    }
    
    function interBankTransfer(uint amount) private {
        List<Address> bankAddressList = cBank.getOtherBanks();
        address targetBank = bankAddressList[0];
        //TODO Convert targetBank to Object
        //Deposite to self reserve
        //Deduct from target bank reserve
        //Pay target bank interest
        cBank.registerTx(owner, targetBank, amount);
    }
}
