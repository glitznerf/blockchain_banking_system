pragma solidity ^0.6.11;

contract Bank {
    uint private interestRate; //in %
    address private owner;
    uint private bankReserve;
    CentralBank cBank;

    constructor(CentralBank centralBank) public {
        owner = msg.sender;
        interestRate = 20;
        bankReserve = 1000;
        cBank = centralBank;
        require(centralBank.registerBank(this, interestRate), "Interest rate condition was not met.");  
    }

    struct account_holders {
        uint accountBal;
        uint lendAmount;
        uint lastUpdateTime;
    }

    mapping(address => account_holders) customers;

    function withdraw(uint withdrawAmt) public payable {
        require(withdrawAmt <= customers[msg.sender].accountBal, "Account lacks sufficient balance.");
        if (withdrawAmt > bankReserve) {
            interBankTransfer(withdrawAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= withdrawAmt;
        }
        
        customers[msg.sender].accountBal -= withdrawAmt;
        customers[msg.sender].lastUpdateTime = now;
        msg.sender.transfer(withdrawAmt);
    }

    function deposit() external payable {
        uint amount = interestWithAmt(msg.value);
        customers[msg.sender].accountBal += amount;
        bankReserve += amount;
    }

    function lend(uint lendAmt) public payable {
       if (lendAmt > bankReserve) {
            interBankTransfer(lendAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= lendAmt;
        }
        
        customers[msg.sender].lendAmount += lendAmt;
        customers[msg.sender].lastUpdateTime = now;
        msg.sender.transfer(lendAmt);
    }

    function repayLoan() external payable {
        uint amount = msg.value;
        customers[msg.sender].lendAmount = interestWithAmt(customers[msg.sender].lendAmount) - amount;
        bankReserve += amount;
    }

    function getInterestRate() public view returns(uint) {
        require(interestRate >= 0, "Improper interest rate is set");
        return interestRate;
    }

    function updateInterestRate(uint newInterestRate) public {
        require(msg.sender == owner, "You are not allowed to update the interest rate");
        interestRate = newInterestRate;
    }

    function internalCustomerTransfer(address destination, uint amount) external {
        require(amount <= customers[msg.sender].accountBal, "Balance is not sufficient");
        customers[msg.sender].accountBal = interestWithAmt(customers[msg.sender].accountBal) - amount;
        customers[destination].accountBal = interestWithAmt(customers[destination].accountBal) + amount;
    }
    
    function interestWithAmt(uint principle) private returns(uint) {
        uint months = uint(ufixed(now-customers[msg.sender].lastUpdateTime)/(3600*24*30));
        ufixed interest = ufixed(principle*interestRate*months)/1200;
        customers[msg.sender].lastUpdateTime = now;
        return principle + uint(interest);
    }
    
    function interBankTransfer(uint amount) private {
        Banks[] banksList = cBank.getOtherBanks();
        uint i = 0;
        uint len = banksList.length;
        while (i < len) {
            if (this != banksList[i]) {
                Bank bank = banksList[i];
                if(bank.getAdvance(amount)) {
                    bankReserve += amount;
                    break;
                }
            }
            i+=1;
        }
        
        if (i < len) {
            cBank.registerTx(owner, banksList[i], amount);
        }
    }
    
    function getAdvance(uint amount) public returns(bool) {
        if (bankReserve < amount) {
            return false;
        }
        //TODO add interest for msg.sender
        bankReserve -= amount;
        return true;
    }
}
