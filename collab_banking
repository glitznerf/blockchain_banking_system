pragma solidity ^0.6.11;

// Assumptions:
//      - banks require no minimum reserve
//      - interest is the same for savings account and loans
//      - everyone and every bank is allowed to borrow money and to the same conditions (no risk premium)
//      - the central bank gives out interest-free loans
//      - interbank transfers are free of interest, because the lender of lenders (central bank) can provide liquidity for free
//      - interbank transfers and central bank loans need to be recorded in a central bank registry, by timestamp
//      - negative interest rates are permitted in (commercial) banks


contract CentralBank {
    uint CbLoans;
    uint MaxCbLoans = 100000000000000000000000000;
    uint maxInterestRate = 30;

    struct bank {
        Bank bank;
        address owner;
        uint interestRate;
    }

    struct tx {                         // Interbank transaction structure
        address lender;
        address receiver;
        uint time;
        uint amount;
    }

    mapping(address => bank) banks;
    Bank[] bankList;
    mapping(uint => tx) Tx;
    uint[] TxList;

    function registerBank(Bank commBank, address owner, uint interestRate) external returns(bool){
        if (0 <= interestRate && interestRate < maxInterestRate) {
            //"InterestRate must be within 0% and 100%!"
            return false;
        }
        banks[owner] = bank(commBank, owner, interestRate);
        bankList.push(commBank);

        return true;
    }

    function getOtherBanks() external returns(Bank[] memory) {
        return bankList;
    }

    function registerTx(address receiver, address lender, uint amount) public {
        uint time = uint(now);
        Tx[time] = (lender, receiver, time, amount);
        TxList.push(time);
    }

    function cbLend(address payable receiver, uint amount) external {                      // Central bank lending to commercial bank only
        require(CbLoans+amount <= MaxCbLoans, "Amount exceeds max permitted CB loans!");
        registerTx(receiver, this, amount);
        CbLoans += amount;
        receiver.transfer(amount);
    }

    function repayCb(address sender, uint amount) external {
        registerTx(this, sender, amount);
        CbLoans -= amount;
    }

}

contract Bank {
    uint private interestRate;          // interest rate in %
    address private owner;              // owner of the bank
    uint private bankReserve;
    CentralBank cBank;                  // init central bank

    constructor(CentralBank centralBank) public {
        owner = msg.sender;
        interestRate = 20;
        bankReserve = 1000;
        cBank = centralBank;
        require(cBank.registerBank(this, owner, interestRate), "Interest rate condition was not met.");
    }

    struct accountHolder {
        uint accountBal;
        uint lendAmount;
        uint lastUpdateTime;
    }

    mapping(address => accountHolder) users;

    //Information about the account holder
    function accountInfo() public view returns(accountHolder memory) {
        return users[msg.sender];
    }

    //Withdraw amount from self account
    function withdraw(uint withdrawAmt) external {
        users[msg.sender].accountBal = getInterestWithBal(users[msg.sender].accountBal);
        require(withdrawAmt <= users[msg.sender].accountBal, "Account lacks sufficient balance.");
        
        //If we dont have enough reserve, we need to ask funds from other banks
        if (withdrawAmt > bankReserve) {
            interBankTransfer(withdrawAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= withdrawAmt;
        }

        users[msg.sender].accountBal -= withdrawAmt;
        msg.sender.transfer(withdrawAmt);
    }

    //Deposit amount into self account
    function deposit() external payable {
        users[msg.sender].accountBal = getInterestWithBal(users[msg.sender].accountBal) + msg.value;
        bankReserve += msg.value;
    }

    //Lend money to bank users
    function lend(uint lendAmt) public {
        //Ask funds from other banks when there isn't enough funds
        if (lendAmt > bankReserve) {
            interBankTransfer(lendAmt - bankReserve);
            bankReserve = 0;
        } else {
            bankReserve -= lendAmt;
        }

        users[msg.sender].lendAmount += lendAmt;
        users[msg.sender].lastUpdateTime = now;
        msg.sender.transfer(lendAmt);
    }

    //Repay back the loan
    function repayLoan() external payable {
        uint amount = msg.value;
        users[msg.sender].lendAmount = getInterestWithBal(users[msg.sender].lendAmount) - amount;
        bankReserve += amount;
    }

    // Publically visible interest rate
    function getInterestRate() public view returns(uint) {
        return interestRate;
    }

    //Update interest rate only by the owner
    function updateInterestRate(uint newInterestRate) public {
        require(msg.sender == owner, "You are not allowed to update the interest rate!");
        require(0 < newInterestRate && newInterestRate < 100, "InterestRate must be within 0% and 100%");
        interestRate = newInterestRate;
    }

    //Customers can transfer funds from there bank to someone within the same bank
    function interCustomerTransfer(address destination, uint amount) external {
        require(amount <= users[msg.sender].accountBal, "Balance is not sufficient");
        users[msg.sender].accountBal = getInterestWithBal(users[msg.sender].accountBal) - amount;
        users[destination].accountBal = getInterestWithBal(users[destination].accountBal) + amount;
    }

    //Interest is calculated based on months in simple interest
    function getInterestWithBal(uint balance) private returns(uint) {
        uint months = uint(ufixed(now- users[msg.sender].lastUpdateTime)/(60*60*24*30));

        ufixed interest = ufixed(balance *interestRate*months)/1200;
        users[msg.sender].lastUpdateTime = now;
        return balance + uint(interest);
    }

    //API to get transfers from other banks
    function interBankTransfer(uint amount) private payable {
        Bank[] memory bankList = cBank.getOtherBanks();

        uint i = 0;
        uint len = bankList.length;
        while (i < len) {
            //Bank list shouldn't be the bank initiaing the call
            if (this != bankList[i]) {
                Bank bank = bankList[i];
                // getAdvance will return bool value based on if it can give return or not.
                if(bank.getAdvance(amount)) {
                    bankReserve += amount;
                    break;
                }
            }
            i+=1;
        }

        if (i < len) {                                          // Register inter bank transfer in central bank!
            cBank.registerTx(this, bankList[i], amount);
        } else {                                                // Get funds from central bank!
            cBank.cbLend(msg.sender, amount);
        }
    }

    //Repay the central bank
    function repayCb(uint amount) public payable {
        cBank.repayCb(this, amount);
        cBank.transfer(amount);
    }

    //Send advance to the requesting bank. Return false if bank lacks required funds
    function getAdvance(uint amount) public returns(bool) {
        if (bankReserve < amount) {
            return false;
        }

        // Other Banks will also be treated as User
        users[msg.sender].lendAmount = getInterestWithBal(users[msg.sender].lendAmount) + amount;
        msg.sender.transfer(amount);

        bankReserve -= amount;
        return true;
    }
}
